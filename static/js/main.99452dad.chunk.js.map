{"version":3,"sources":["components/Dot.tsx","components/CanvasImg.tsx","components/CanvasImgWrapper.tsx","components/Profile.tsx","components/ProfileWrapper.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Dot","memo","ctx","size","name","wrapper","useState","dots","setDots","dotRef","useRef","getXY","useCallback","el","offsetWidth","offsetHeight","x","offsetLeft","y","offsetTop","onMouseEnter","e","current","classList","remove","add","useEffect","dot","colorData","getImageData","data","style","backgroundColor","clientWidth","addEventListener","once","ref","className","width","height","map","item","key","toString","CanvasImg","screenSize","ctxState","setCtxState","canvasRef","onLoad","target","canvas","img","getWidthHeight","getContext","drawImage","setCanvas","alt","src","CanvasImgWrapper","member","id","Profile","setName","select","onClick","backgroundImage","ProfileWrapper","App","initialDotSize","setInitialDotSize","initialDots","setInitialDots","setScreenSize","memberRef","dotWrapperRef","imgRef","settingInit","imgWidth","imgHeight","dotWrapper","setDotWrapper","onReSize","window","innerWidth","innerHeight","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.99452dad.chunk.js","sourcesContent":["import React, { useRef, useEffect, useState, memo, useCallback } from \"react\";\n\nconst Dot = memo(({ ctx, size, name, wrapper }: any) => {\n  const [dots, setDots] = useState<Array<any>>([]);\n  const dotRef = useRef<HTMLDivElement>(null);\n\n  const getXY = useCallback(\n    (el: HTMLDivElement) => {\n      const { offsetWidth, offsetHeight } = wrapper;\n\n      let x = el.offsetLeft + el.offsetWidth / 2,\n        y = el.offsetTop + el.offsetHeight / 2;\n\n      x = x < 0 ? 0 : x;\n      y = y < 0 ? 0 : y;\n\n      x = x > offsetWidth ? offsetWidth - 1 : x;\n      y = y > offsetHeight ? offsetHeight - 1 : y;\n\n      return { x, y };\n    },\n    [wrapper]\n  );\n\n  const onMouseEnter = (e: any) => {\n    // element what has dot class remove dot class then add wrapper class\n    if (dotRef.current && e) {\n      dotRef.current.classList.remove(\"dot\");\n      dotRef.current.classList.add(\"wrapper\");\n      setDots([1, 2, 3, 4]);\n    }\n  };\n\n  useEffect(() => {\n    // init dot setting\n    if (dotRef.current && ctx[name]) {\n      const dot = dotRef.current;\n      const { x, y } = getXY(dot);\n      const colorData = ctx[name].getImageData(x, y, 1, 1).data;\n      dot.style.backgroundColor = `rgb(${colorData[0]},${colorData[1]},${colorData[2]})`;\n      if (dot.clientWidth >= 10) {\n        dot.addEventListener(\"mouseenter\", onMouseEnter, { once: true });\n      }\n    }\n  }, [size, ctx, name, getXY]);\n  return (\n    <div ref={dotRef} className=\"dot\" style={{ width: size, height: size }}>\n      {dots.map((item) => {\n        return (\n          <Dot\n            size={size / 2}\n            key={item.toString()}\n            ctx={ctx}\n            name={name}\n            wrapper={wrapper}\n          />\n        );\n      })}\n    </div>\n  );\n});\n\nexport default Dot;\n","import React, { memo, useRef } from \"react\";\n\nconst CanvasImg = memo(({ name, screenSize, ctxState, setCtxState }: any) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  const getWidthHeight = (img: HTMLImageElement) => {\n    let { width, height } = img;\n    if (width < height) {\n      if (width > screenSize[0] * 0.8) {\n        height = (height / width) * screenSize[0] * 0.8;\n        width = screenSize[0] * 0.8;\n      }\n      // if (height > screenSize[1] * 0.5) {\n      //   width = (width / height) * screenSize[1] * 0.5;\n      //   height = screenSize[1] * 0.5;\n      // }\n    } else if (width > height) {\n    }\n\n    return { width, height };\n  };\n\n  const setCanvas = (\n    // set canvas size and draw image and return ctx\n    canvas: HTMLCanvasElement,\n    img: HTMLImageElement,\n    width: number,\n    height: number\n  ): CanvasRenderingContext2D => {\n    const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    canvas.width = width;\n    canvas.height = height;\n    ctx.drawImage(img, 0, 0, width, height);\n    return ctx;\n  };\n\n  const onLoad = (e: any) => {\n    if (canvasRef.current && e.target) {\n      const canvas = canvasRef.current as HTMLCanvasElement;\n      const img = e.target;\n      const size = getWidthHeight(img);\n      const ctx = setCanvas(canvas, img, size.width, size.height);\n      setCtxState({ ...ctxState, [name]: ctx });\n    }\n  };\n\n  return (\n    <div className={`${name}-wrapper`}>\n      <img\n        onLoad={onLoad}\n        className={name}\n        alt={name}\n        src={`./img/${name}.jpg`}\n      />\n      <canvas ref={canvasRef} className={name}></canvas>\n    </div>\n  );\n});\n\nexport default CanvasImg;\n","import React, { memo } from \"react\";\nimport CanvasImg from \"./CanvasImg\";\n\nconst CanvasImgWrapper = memo(\n  ({ member, screenSize, ctxState, setCtxState }: any) => {\n    return (\n      <div id=\"canvas-wrapper\">\n        {member.map((item: string) => {\n          return (\n            <CanvasImg\n              name={item}\n              key={item}\n              screenSize={screenSize}\n              ctxState={ctxState}\n              setCtxState={setCtxState}\n            />\n          );\n        })}\n      </div>\n    );\n  }\n);\n\nexport default CanvasImgWrapper;\n","import React, { memo } from \"react\";\n\nconst Profile = memo(({ name, setName, select }: any) => {\n  const onClick = (e: any) => {\n    setName(name);\n  };\n  return (\n    <div\n      onClick={onClick}\n      className={select ? \"profile selected\" : \"profile\"}\n      style={{ backgroundImage: `url(./img/${name}.jpg)` }}\n    ></div>\n  );\n});\n\nexport default Profile;\n","import React, { memo } from \"react\";\nimport Profile from \"./Profile\";\n\nconst ProfileWrapper = memo(({ member, setName, name }: any) => {\n  return (\n    <div id=\"profile-wrapper\">\n      <div id=\"profile-slide\">\n        {member.map((item: any) => {\n          if (item === name) {\n            return (\n              <Profile\n                name={item}\n                key={item}\n                setName={setName}\n                select={true}\n              ></Profile>\n            );\n          }\n          return <Profile name={item} key={item} setName={setName}></Profile>;\n        })}\n      </div>\n    </div>\n  );\n});\n\nexport default ProfileWrapper;\n","import React, { useState, useRef, memo, useEffect } from \"react\";\nimport \"./reset.css\";\nimport \"./App.css\";\nimport Dot from \"./components/Dot\";\nimport CanvasImgWrapper from \"./components/CanvasImgWrapper\";\nimport ProfileWrapper from \"./components/ProfileWrapper\";\n\nconst App = memo(() => {\n  const [name, setName] = useState<string>(\"kimchaewon\");\n  const [initialDotSize, setInitialDotSize] = useState<number>(0);\n  const [initialDots, setInitialDots] = useState<Array<number>>([]);\n  const [screenSize, setScreenSize] = useState<Array<number>>([0, 0]);\n  const [ctxState, setCtxState] = useState<object>({});\n  const memberRef = useRef<Array<string>>([\n    \"kwoneunbi\",\n    \"sakura\",\n    \"kanghyewon\",\n    \"choiyena\",\n    \"leechaeyeon\",\n    \"kimchaewon\",\n    \"kimminju\",\n    \"nako\",\n    \"hitomi\",\n    \"joyuri\",\n    \"anyujin\",\n    \"jangwonyoung\",\n  ]);\n  const dotWrapperRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const imgRef = useRef<HTMLImageElement>(null);\n\n  const setDotWrapper = (imgWidth: number, imgHeight: number) => {\n    // set dot-wrapper size\n    if (dotWrapperRef.current) {\n      const dotWrapper = dotWrapperRef.current as HTMLDivElement;\n      dotWrapper.style.width = `${imgWidth}px`;\n      dotWrapper.style.height = `${imgHeight}px`;\n      setInitialDots([1, 2, 3, 4, 5, 6]);\n    }\n  };\n\n  const getWidthHeight = (img: HTMLImageElement) => {\n    let { width, height } = img;\n    if (width < height) {\n      if (width > screenSize[0] * 0.8) {\n        height = (height / width) * screenSize[0] * 0.8;\n        width = screenSize[0] * 0.8;\n      }\n      // if (height > screenSize[1] * 0.5) {\n      //   width = (width / height) * screenSize[1] * 0.5;\n      //   height = screenSize[1] * 0.5;\n      // }\n    } else if (width > height) {\n    }\n\n    return { width, height };\n  };\n\n  const settingInit = () => {\n    if (canvasRef.current && imgRef.current) {\n      const img = imgRef.current as HTMLImageElement;\n      const size = getWidthHeight(img);\n      setDotWrapper(size.width, size.height);\n      setInitialDotSize(350);\n    }\n  };\n\n  const imgOnLoad = () => {\n    // when img is loaded, init system\n    settingInit();\n  };\n\n  const onReSize = () => {\n    setScreenSize([window.innerWidth, window.innerHeight]);\n  };\n\n  useEffect(() => {\n    // when document is loaded, set screenSize state at once\n    onReSize();\n    window.addEventListener(\"resize\", onReSize);\n  }, []);\n  return (\n    <>\n      <CanvasImgWrapper\n        member={memberRef.current}\n        screenSize={screenSize}\n        ctxState={ctxState}\n        setCtxState={setCtxState}\n      />\n      <div id=\"main-wrapper\">\n        <img\n          onLoad={imgOnLoad}\n          alt={name}\n          src={`./img/${name}.jpg`}\n          ref={imgRef}\n        ></img>\n        <canvas ref={canvasRef}></canvas>\n        {/* <DotWrapper ref={dotWrapperRef}></DotWrapper> */}\n        <div ref={dotWrapperRef} className=\"wrapper\" id=\"dot-wrapper\">\n          {initialDots.map((item) => (\n            <Dot\n              size={initialDotSize}\n              ctx={ctxState}\n              key={item.toString()}\n              name={name}\n              wrapper={dotWrapperRef.current}\n            />\n          ))}\n        </div>\n      </div>\n      <ProfileWrapper\n        member={memberRef.current}\n        setName={setName}\n        name={name}\n      ></ProfileWrapper>\n    </>\n  );\n});\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import \"react-app-polyfill/ie11\";\nimport \"react-app-polyfill/stable\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}